/**  	Graffiti 3.0*  	______________________________________________________________________*  	www.nocircleno.com/graffiti/*//** 	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,* 	EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES* 	OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND* 	NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT* 	HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,* 	WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING* 	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR* 	OTHER DEALINGS IN THE SOFTWARE.*/package com.nocircleno.graffiti.converters ;import com.nocircleno.graffiti.display.LineObject;import com.nocircleno.graffiti.display.BrushObject;import com.nocircleno.graffiti.display.GraffitiObject;import com.nocircleno.graffiti.display.ShapeObject;import com.nocircleno.graffiti.display.TextObject;import com.nocircleno.graffiti.tools.*;import com.nocircleno.graffiti.utils.Conversions;import openfl.display.GraphicsPathCommand;import openfl.events.Event;import openfl.geom.Point;import openfl.geom.Rectangle;import openfl.text.Font;import openfl.text.FontType;import openfl.text.FontStyle;import openfl.text.TextFormat;/*** The DegrafaConverter Class lets you translate objects drawn with the Graffiti Library to Degrafa markup and back.*/class DegrafaConverter{	public function new() { }	/**	* The <code>from</code> method take defrafa xml data and convert it into a list of GraffitiObjects.	*	* @param degrafaXml Degrafa Xml	*	* @return Returns a list of Graffiti Objects.	*/	public static function from(degrafaXml:Xml  ):Array<GraffitiObject>	{		var objectList:Array<GraffitiObject> = new Array<GraffitiObject>();		// create graffiti objects from geometry		var objs:XmlList = degrafaXml.GeometryGroup;		var numberObjects:Int = objs.length();		var bObject:BrushObject;		var sObject:ShapeObject;		var tObject:TextObject;		var lObject:LineObject;		var color:Int;		var hexColor:String;		var size:Float;		var alpha:Float;		var objID:String;		var styleTag:String;		var i:Int;		var j:Int;		var k:Int;		var commands:Array<Int>;		var drawingData:Array<Float>;		var dataSplit:Array;		var dataLength:Int;		var positionSplit:Array;		for (i = 0; i < numberObjects; ++i)		{			objID = objs[i].@id;			commands = new Array<Int>();			drawingData = new Array<Float>();			if (objID.indexOf("brush") != -1)			{				var brushType:String = objID.split("_")[1];				if (brushType == BrushType.ROUND)				{					styleTag = objs[i].Path.@stroke;					styleTag = styleTag.substring(1, styleTag.length - 1);					hexColor = degrafaXml.strokes.SolidStroke.(@id == styleTag).@color;					color = Std.parseInt(hexColor.replace("#", "0x"));					alpha = Std.parseFloat(degrafaXml.strokes.SolidStroke.(@id == styleTag).@alpha);					size = Std.parseFloat(degrafaXml.strokes.SolidStroke.(@id == styleTag).@weight);				}				else				{					styleTag = objs[i].Path.@fill;					styleTag = styleTag.substring(1, styleTag.length - 1);					hexColor = degrafaXml.fills.SolidFill.(@id == styleTag).@color;					color = Std.parseInt(hexColor.replace("#", "0x"));					alpha = Std.parseFloat(degrafaXml.fills.SolidFill.(@id == styleTag).@alpha);					size = 8;				}				dataSplit = objs[i].Path.@data.split(" ");				dataLength = dataSplit.length;				for (j = 0; j < dataLength; ++j)				{					if (dataSplit[j] == "M")					{						commands.push(GraphicsPathCommand.MOVE_TO);						positionSplit = dataSplit[j + 1].split(",");						drawingData.push(Std.parseFloat(positionSplit[0]));						drawingData.push(Std.parseFloat(positionSplit[1]));						j++;					}					else if (dataSplit[j] == "L")					{						commands.push(GraphicsPathCommand.LINE_TO);						positionSplit = dataSplit[j + 1].split(",");						drawingData.push(Std.parseFloat(positionSplit[0]));						drawingData.push(Std.parseFloat(positionSplit[1]));						j++;					}				}				bObject = new BrushObject(new BrushDefinition(brushType, color, alpha, size, 0, commands, drawingData, new PoStd.parseInt(Std.parseFloat(objs[i].@x), Std.parseFloat(objs[i].@y))));				bObject.x = Std.parseFloat(objs[i].@x);				bObject.y = Std.parseFloat(objs[i].@y);				objectList.push(bObject);			}			else if (objID.indexOf("line") != -1)			{				var lineType:String = objID.split("_")[1];				styleTag = objs[i].Path.@stroke;				styleTag = styleTag.substring(1, styleTag.length - 1);				hexColor = degrafaXml.strokes.SolidStroke.(@id == styleTag).@color;				color = Std.parseInt(hexColor.replace("#", "0x"));				alpha = Std.parseFloat(degrafaXml.strokes.SolidStroke.(@id == styleTag).@alpha);				size = Std.parseFloat(degrafaXml.strokes.SolidStroke.(@id == styleTag).@weight);				dataSplit = objs[i].Path.@data.split(" ");				dataLength = dataSplit.length;				for (j = 0; j < dataLength; ++j)				{					if (dataSplit[j] == "M")					{						commands.push(GraphicsPathCommand.MOVE_TO);						positionSplit = dataSplit[j + 1].split(",");						drawingData.push(Std.parseFloat(positionSplit[0]));						drawingData.push(Std.parseFloat(positionSplit[1]));						j++;					}					else if (dataSplit[j] == "L")					{						commands.push(GraphicsPathCommand.LINE_TO);						positionSplit = dataSplit[j + 1].split(",");						drawingData.push(Std.parseFloat(positionSplit[0]));						drawingData.push(Std.parseFloat(positionSplit[1]));						j++;					}					else if (dataSplit[j] == "C")					{						commands.push(GraphicsPathCommand.CURVE_TO);						positionSplit = dataSplit[j + 1].split(",");						drawingData.push(Std.parseFloat(positionSplit[0]));						drawingData.push(Std.parseFloat(positionSplit[1]));						drawingData.push(Std.parseFloat(positionSplit[2]));						drawingData.push(Std.parseFloat(positionSplit[3]));						j++;					}				}				lObject = new LineObject(new LineDefinition(lineType, color, alpha, size, Std.parseFloat(objs[i].Path.@width), Std.parseFloat(objs[i].Path.@height), commands, drawingData, new PoStd.parseInt(Std.parseFloat(objs[i].@x), Std.parseFloat(objs[i].@y))));				lObject.x = Std.parseFloat(objs[i].@x);				lObject.y = Std.parseFloat(objs[i].@y);				objectList.push(lObject);			}			else if (objID.indexOf("shape") != -1)			{				var shapeType:String = objID.split("_")[1];				var fillColor:Int;				var fillAlpha:Float;				var strokeColor:Int;				var strokeAlpha:Float;				var strokeSize:Float;				var fillStyleID:String;				var strokeStyleID:String;				var shapeWidth:Float;				var shapeHeight:Float;				if (shapeType == ShapeType.CIRCLE || shapeType == ShapeType.OVAL)				{					strokeStyleID = objs[i].Ellipse.@stroke;					fillStyleID = objs[i].Ellipse.@fill;					var controlAngleRadians:Float;					var anchorAngleRadians:Float;					var xControl:Float;					var yControl:Float;					var xAnchor:Float;					var yAnchor:Float;					shapeWidth = Std.parseFloat(objs[i].Ellipse.@width);					shapeHeight = Std.parseFloat(objs[i].Ellipse.@height);					var theta:Int = 45;					var r:Float = Std.parseFloat(objs[i].Ellipse.@width)/2;					var r2:Float = Std.parseFloat(objs[i].Ellipse.@height)/2;					var d:Float = r/Math.cos(Conversions.radians(0.5*theta));					var d2:Float = r2/Math.cos(Conversions.radians(0.5*theta));					var centerPoint:Point = new PoStd.parseInt(r, r2);					commands.push(GraphicsPathCommand.MOVE_TO);					drawingData.push(centerPoint.x + r);					drawingData.push(centerPoint.y);					// draw the new preview circle					for (k=(theta/2); k<361; k=k+theta)					{						controlAngleRadians = Conversions.radians(k);						anchorAngleRadians = Conversions.radians(k+(theta/2));						xControl = d*Math.cos(controlAngleRadians);						yControl = d2*Math.sin(controlAngleRadians);						xAnchor = r*Math.cos(anchorAngleRadians);						yAnchor = r2*Math.sin(anchorAngleRadians);						commands.push(GraphicsPathCommand.CURVE_TO);						drawingData.push(centerPoint.x + xControl);						drawingData.push(centerPoint.y + yControl);						drawingData.push(centerPoint.x + xAnchor);						drawingData.push(centerPoint.y + yAnchor);					}				}				else if (shapeType == ShapeType.RECTANGLE || shapeType == ShapeType.SQUARE)				{					strokeStyleID = objs[i].RegularRectangle.@stroke;					fillStyleID = objs[i].RegularRectangle.@fill;					shapeWidth = Std.parseFloat(objs[i].RegularRectangle.@width);					shapeHeight = Std.parseFloat(objs[i].RegularRectangle.@height);					commands.push(GraphicsPathCommand.LINE_TO);					drawingData.push(Std.parseFloat(objs[i].RegularRectangle.@width));					drawingData.push(0);					commands.push(GraphicsPathCommand.LINE_TO);					drawingData.push(Std.parseFloat(objs[i].RegularRectangle.@width));					drawingData.push(Std.parseFloat(objs[i].RegularRectangle.@height));					commands.push(GraphicsPathCommand.LINE_TO);					drawingData.push(0);					drawingData.push(Std.parseFloat(objs[i].RegularRectangle.@height));					commands.push(GraphicsPathCommand.LINE_TO);					drawingData.push(0);					drawingData.push(0);				}				// create stroke properties from xml				if (strokeStyleID != "")				{					strokeStyleID = strokeStyleID.substring(1, strokeStyleID.length - 1);					hexColor = degrafaXml.strokes.SolidStroke.(@id == strokeStyleID).@color;					strokeColor = Std.parseInt(hexColor.replace("#", "0x"));					strokeAlpha = Std.parseFloat(degrafaXml.strokes.SolidStroke.(@id == strokeStyleID).@alpha);					strokeSize = Std.parseFloat(degrafaXml.strokes.SolidStroke.(@id == strokeStyleID).@weight);				}				else				{					strokeColor = -1;					strokeAlpha = 1;					strokeSize = 8;				}				// create fill properties from xml				if (fillStyleID != "")				{					fillStyleID = fillStyleID.substring(1, fillStyleID.length - 1);					hexColor =  degrafaXml.fills.SolidFill.(@id == fillStyleID).@color;					fillColor = Std.parseInt(hexColor.replace("#", "0x"));					fillAlpha = Std.parseFloat(degrafaXml.fills.SolidFill.(@id == fillStyleID).@alpha);				}				else				{					fillColor = -1;					fillAlpha = 0;				}				sObject = new ShapeObject(new ShapeDefinition(shapeType, strokeColor, fillColor, strokeAlpha, fillAlpha, strokeSize, shapeWidth, shapeHeight, commands, drawingData, new PoStd.parseInt(Std.parseFloat(objs[i].@x), Std.parseFloat(objs[i].@y))));				sObject.x = Std.parseFloat(objs[i].@x);				sObject.y = Std.parseFloat(objs[i].@y);				objectList.push(sObject);			}		}		///////////////////////////////////////////////////////////		// Create graffiti objects from text		///////////////////////////////////////////////////////////		var textObjs:XmlList = degrafaXml.RasterText;		numberObjects = textObjs.length();		for (i = 0; i < numberObjects; ++i)		{			/*			objectXml = <RasterText color={hexColor} inheritFill="false" inheritStroke="false"								embedFonts={embedFonts} autoSizeField="true"								text = {escape(tObject.text)} fontFamily = {fontName}								fontWeight = {fontWeight} backgroundColor = {bgColor}								fontSize={String(tObject.textSetting.textFormat.size)} borderColor={borderColor} x={String(tObject.x)} y={String(tObject.y)} >							</RasterText>;			*/			var embedFonts:Boolean = textObjs[i].@embedFonts == "true" ? true : false;			var font:Font;			var fontName:String = textObjs[i].@fontFamily;			var fontList:Array = Font.enumerateFonts(!embedFonts);			var numberFonts:Int = fontList.length;			for ( j=0; j<numberFonts; ++j )			{				if (fontList[j].fontName == fontName)				{					font = Font(fontList[j]);					break;				}			}			if (font == null)			{				font = Font(fontList[0]);			}			var bgColor:String = textObjs[i].@backgroundColor;			var borderColor:String = textObjs[i].@borderColor;			var textColor:String = textObjs[i].@color;			if (bgColor != "#-1")			{				bgColor = bgColor.replace("#", "0x");			}			else			{				bgColor = "-1";			}			if (borderColor != "#-1")			{				borderColor = borderColor.replace("#", "0x");			}			else			{				borderColor = "-1";			}			textColor = textColor.replace("#", "0x");			var fmt:TextFormat = new TextFormat();			fmt.font = fontName;			fmt.color = Std.parseInt(textColor);			fmt.size = Std.parseInt(textObjs[i].@fontSize);			fmt.bold = textObjs[i].@fontWeight == "bold" ? true : false;			var ts:TextSettings = new TextSettings(font, fmt, Std.parseInt(bgColor), Std.parseInt(borderColor));			tObject = new TextObject(ts);			tObject.text = unescape(textObjs[i].@text);			tObject.x = Std.parseFloat(textObjs[i].@x);			tObject.y = Std.parseFloat(textObjs[i].@y);			var insertPosition:Int = Std.parseInt(textObjs[i].@id.split("_")[1]);			if (insertPosition >= objectList.length)			{				objectList.push(tObject);			}			else			{				objectList.splice(insertPosition, 0, tObject);			}		}		return objectList;	}	/**	* The <code>to</code> method converts all Graffiti Objects into degrafa xml.	*	* @param graffitiObjectList A list of GraffitiObjects.	*	* @return Returns an xml object.	*/	public static function to(graffitiObjectList:Array<GraffitiObject>):Xml	{		var i:Int;		var j:Int;		var objectXml:Xml;		var degrafaXml:Xml = <Surface>		<fills></fills>		<strokes></strokes>		</Surface>;		var numberObjects:Int = graffitiObjectList.length;		var gObject:GraffitiObject;		var bObject:BrushObject;		var sObject:ShapeObject;		var lObject:LineObject;		var tObject:TextObject;		var color:Int;		var alpha:Float;		var size:Float;		var strokeID:String;		var fillID:String;		var objectID:String;		var pathData:String;		var numberOfDataPoint:Int;		for (i = 0; i < numberObjects; ++i)		{			gObject = graffitiObjectList[i];			if (gObject is BrushObject)			{				bObject = BrushObject(gObject);				// get properties				color = bObject.brushDefinition.color;				alpha = bObject.brushDefinition.alpha;				size = bObject.brushDefinition.size;				// create object id from brush type and count				objectID = "brush_" + bObject.brushDefinition.type + "_" + i;				// get path data				pathData = convertDrawingCommandsToPath(bObject.brushDefinition.commands, bObject.brushDefinition.drawingData);				if (bObject.brushDefinition.type == BrushType.ROUND)				{					// get stroke id					strokeID = getStrokeID(degrafaXml, color, alpha, size);					objectXml = <GeometryGroup id= {objectID} x= {bObject.x} y= {bObject.y}>					<Path stroke= {strokeID} data= {pathData}></Path></GeometryGroup>;				}				else				{					fillID = getFillID(degrafaXml, color, alpha);					objectXml = <GeometryGroup id= {objectID} x= {bObject.x} y= {bObject.y}>												   <Path fill= {fillID} data= {pathData}></Path></GeometryGroup>;				}				// add object to xml				degrafaXml.appendChild(objectXml);			}			else if (gObject is ShapeObject)			{				sObject = ShapeObject(gObject);				// get fill id				if (sObject.shapeDefinition.fillColor != -1)				{					fillID = getFillID(degrafaXml, sObject.shapeDefinition.fillColor, sObject.shapeDefinition.fillAlpha);				}				else				{					fillID = null;				}				// get stroke id				if (sObject.shapeDefinition.strokeColor != -1)				{					strokeID = getStrokeID(degrafaXml, sObject.shapeDefinition.strokeColor, sObject.shapeDefinition.strokeAlpha, sObject.shapeDefinition.strokeSize);				}				else				{					strokeID = null;				}				// create object id from brush type and count				objectID = "shape_" + sObject.shapeDefinition.type + "_" + i;				if (sObject.shapeDefinition.type == ShapeType.OVAL || sObject.shapeDefinition.type == ShapeType.CIRCLE)				{					if (fillID == null)					{						objectXml = <GeometryGroup id= {objectID} x= {String(sObject.x)} y= {String(sObject.y)}>													   <Ellipse stroke= {strokeID} height= {String(sObject.shapeDefinition.height)} width= {String(sObject.shapeDefinition.width)}/>															   </GeometryGroup>;					}					else if (strokeID == null)					{						objectXml = <GeometryGroup id= {objectID} x= {String(sObject.x)} y= {String(sObject.y)}>													   <Ellipse fill= {fillID} height= {String(sObject.shapeDefinition.height)} width= {String(sObject.shapeDefinition.width)}/>															   </GeometryGroup>;					}					else					{						objectXml = <GeometryGroup id= {objectID} x= {String(sObject.x)} y= {String(sObject.y)}>													   <Ellipse stroke= {strokeID} fill= {fillID} height= {String(sObject.shapeDefinition.height)} width= {String(sObject.shapeDefinition.width)}/>															   </GeometryGroup>;					}				}				else if (sObject.shapeDefinition.type == ShapeType.RECTANGLE || sObject.shapeDefinition.type == ShapeType.SQUARE)				{					if (fillID == null)					{						objectXml = <GeometryGroup id= {objectID} x= {String(sObject.x)} y= {String(sObject.y)}>													   <RegularRectangle stroke= {strokeID} height= {String(sObject.shapeDefinition.height)} width= {String(sObject.shapeDefinition.width)}/>															   </GeometryGroup>;					}					else if (strokeID == null)					{						objectXml = <GeometryGroup id= {objectID} x= {String(sObject.x)} y= {String(sObject.y)}>													   <RegularRectangle fill= {fillID} height= {String(sObject.shapeDefinition.height)} width= {String(sObject.shapeDefinition.width)}/>															   </GeometryGroup>;					}					else					{						objectXml = <GeometryGroup id= {objectID} x= {String(sObject.x)} y= {String(sObject.y)}>													   <RegularRectangle stroke= {strokeID} fill= {fillID} height= {String(sObject.shapeDefinition.height)} width= {String(sObject.shapeDefinition.width)}/>															   </GeometryGroup>;					}				}				// add object to xml				degrafaXml.appendChild(objectXml);			}			else if (gObject is LineObject)			{				lObject = LineObject(gObject);				// get stroke id				strokeID = getStrokeID(degrafaXml, lObject.lineDefinition.strokeColor, lObject.lineDefinition.strokeAlpha, lObject.lineDefinition.strokeSize);				// create object id from brush type and count				objectID = "line_" + lObject.lineDefinition.type + "_" + i;				// get path data				pathData = convertDrawingCommandsToPath(lObject.lineDefinition.commands, lObject.lineDefinition.drawingData);				objectXml = <GeometryGroup id= {objectID} x= {lObject.x} y= {lObject.y}>											   <Path stroke= {strokeID} width= {lObject.lineDefinition.width} height= {lObject.lineDefinition.height} data= {pathData}></Path></GeometryGroup>;				// add object to xml				degrafaXml.appendChild(objectXml);			}			else if (gObject is TextObject)			{				tObject = TextObject(gObject);				var hexColor:String = "#" + tObject.textSetting.textFormat.color.toString(16);				var embedFonts:String = tObject.textSetting.embeddedFont ? "true" : "false";				var fontName:String = tObject.textSetting.font.fontName;				var fontWeight:String = tObject.textSetting.textFormat.bold ? "bold" : "normal";				var bgColor:String = "#" + tObject.textSetting.backgroundColor.toString(16);				var borderColor:String = "#" + tObject.textSetting.borderColor.toString(16);				// create object id from brush type and count				objectID = "text_" + i;				objectXml = <RasterText id= {objectID} color= {hexColor} inheritFill="false" inheritStroke="false"											embedFonts= {embedFonts} autoSizeField="true"														text = {escape(tObject.text)} fontFamily = {fontName}																fontWeight = {fontWeight} backgroundColor = {bgColor}																		fontSize= {case(tObject.textSetting.textFormat.size, String)} borderColor= {borderColor} x= {String(tObject.x)} y= {String(tObject.y)} >																				</RasterText>;				// add object to xml				degrafaXml.appendChild(objectXml);			}		}		return degrafaXml;	}	private static function convertDrawingCommandsToPath(commands:Array<Int>, data:Array<Float>):String	{		var pathData:String = "";		// Convert Commands and Data to text string for degrafa output		var numberOfDataPoint:Int = commands.length;		var dataCount:Int = 0;		var padding:String = "";		for (var i:Int = 0; i < numberOfDataPoint; ++i)		{			if (i > 0 )			{				padding = " ";			}			if (commands[i] == GraphicsPathCommand.MOVE_TO)			{				pathData += padding + "M " + data[dataCount] + "," + data[dataCount + 1];				dataCount += 2;			}			else if (commands[i] == GraphicsPathCommand.LINE_TO)			{				pathData += padding + "L " + data[dataCount] + "," + data[dataCount + 1];				dataCount += 2;			}			else if (commands[i] == GraphicsPathCommand.CURVE_TO)			{				pathData += padding + "C " + data[dataCount] + "," + data[dataCount + 1] + "," + data[dataCount + 2] + "," + data[dataCount + 3];				dataCount += 4;			}		}		pathData += " z";		return pathData;	}	private static function getFillID(xml:Xml, color:Int, alpha:Float):String	{		var fillID:String;		var hexColor:String = "#" + color.toString(16);		var fillList:XmlList = xml.fills.children();		//////////////////////////////////////////////////////////		// Create or find Stoke entry		//////////////////////////////////////////////////////////		if (fillList.length() > 0)		{			fillID = xml.fills.SolidFill.(@color == hexColor && @alpha == alpha).@id;			// insert new fill tag			if (fillID == "")			{				fillID = "gFill_" + fillList.length();				xml.fills.appendChild(<SolidFill id= {fillID} color= {hexColor} alpha= {alpha}/>);			}		}		else {			fillID = "gFill_0";			xml.fills.appendChild(<SolidFill id={fillID} color={hexColor} alpha={alpha}/>);		}		return "{" + fillID + "}";	}	private static function getStrokeID(xml:Xml, color:Int, alpha:Float, size:Float):String	{		var strokeID:String;		var hexColor:String = "#" + color.toString(16);		var strokeList:XmlList = xml.strokes.children();		//////////////////////////////////////////////////////////		// Create or find Stoke entry		//////////////////////////////////////////////////////////		if (strokeList.length() > 0)		{			strokeID = xml.strokes.SolidStroke.(@color == hexColor && @alpha == alpha && @weight == size).@id;			// insert new stroke tag			if (strokeID == "")			{				strokeID = "gStroke_" + strokeList.length();				xml.strokes.appendChild(<SolidStroke id= {strokeID} color= {hexColor} weight= {size} alpha= {alpha}/>);			}		}		else {			strokeID = "gStroke_0";			xml.strokes.appendChild(<SolidStroke id={strokeID} color={hexColor} weight={size} alpha={alpha}/>);		}		return "{" + strokeID + "}";	}}